#include <iostream>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/dispatch.h>
#include <thread>
#include <chrono>

#define NO_OF_MSGS 5
#define ATTACH_POINT_MASTER "masterService"
#define ATTACH_POINT_SLAVE "clientService"

typedef struct _pulse header_t;

// Messages types of application
#define STR_MSG (_IO_MAX + 1)
#define DATA_MSG (_IO_MAX + 2)

typedef struct {
	int size; // size of data block
	int count; // some counter used by the application
	// further data fields required by application
} app_header_t;

using namespace std;

bool serverRunning;
bool clientRunning;

name_attach_t *attachedService;
int server_coid;

static void handle_pulse(header_t hdr, int rcvid){
	std::cout << "handle_pulse: " << std::to_string(rcvid) << std::endl;
	switch (hdr.code) {
	case _PULSE_CODE_DISCONNECT:
		printf("Server received _PULSE_CODE_DISCONNECT\n");
		/* A client disconnected all its connections (called
		 * name_close() for each name_open() of our name) or
		 * terminated. */
		ConnectDetach(hdr.scoid);
		break;
	case _PULSE_CODE_UNBLOCK:
		printf("Server received _PULSE_CODE_UNBLOCK\n");
		/* REPLY blocked client wants to unblock (was hit by
		 * a signal or timed out). It's up to you if you
		 * reply now or later. */
		break;
	default:
		/* A pulse sent by one of your processes or a
		 * _PULSE_CODE_COIDDEATH or _PULSE_CODE_THREADDEATH
		 * from the kernel? */
		printf("Server received some pulse msg.\n");
		break;
	}
}

static void handle_ONX_IO_msg(header_t hdr, int rcvid){
	std::cout << "handle_pulse: " << std::to_string(rcvid) << std::endl;
	if (hdr.type == _IO_CONNECT ) {
		// QNX IO msg _IO_CONNECT was received; answer with EOK
		printf("Server received _IO_CONNECT (sync. msg) \n");
		MsgReply( rcvid, EOK, NULL, 0 );
		return;
	}
	// Some other QNX IO message was received; reject it
	printf("Server received unexpected (sync.) msg type = 0x%04X\n", hdr.type);
	MsgError( rcvid, ENOSYS );
}

static void handle_app_msg(header_t hdr, int rcvid){
	const char *ret_msg = "Got the message";
	if (DATA_MSG == hdr.type) {
		printf("Server: DATA_MSG not supported.\n");
		MsgError(rcvid,EPERM);
	} else if (STR_MSG == hdr.type) {
		printf("Server: STR_MSG received.\n");
		// read app header
		app_header_t app_header;
		MsgRead(rcvid, &app_header, sizeof(app_header), sizeof(header_t));
		// ToDo Check return value of MsgRead, in particular number of read bytes
		// read payload
		void* buf = malloc(app_header.size); // ToDo check return value of malloc
		MsgRead(rcvid, buf, app_header.size, sizeof(header_t)+sizeof(app_header_t));
		// ToDo Check return value of MsgRead, in particular number of read bytes
		printf("Server: got STR_MSG (count = %d): %s \n", app_header.count, buf);
		MsgReply(rcvid, EOK, ret_msg, strlen(ret_msg) + 1); // send reply
		free(buf);
	} else { // Wrong msg type
		printf("Server: Wrong message type 0x%04X\n", hdr.type);
		MsgError(rcvid,EPERM);
	}
}

void receive_msg() {
	while (1) {
		// Waiting for a message and read first header
		header_t header;
		int rcvid = MsgReceive (attachedService->chid, &header, sizeof (header_t), NULL);
		if (rcvid == -1) { // Error occurred
			perror("Server: MsgReceived failed");
			break;
		}
		if (rcvid == 0) {// Pulse was received
			handle_pulse(header, rcvid);
			continue;
		}
		// continue while (1) loop
		// some sync msg was received
		if ((_IO_BASE <= header.type) && (header.type <= _IO_MAX)) {
			// Some QNX IO msg generated by gns was received
			handle_ONX_IO_msg(header, rcvid);
			continue;
		}
		// A sync msg (presumable ours) was received; handle it
		handle_app_msg(header, rcvid);
	}
}


int create_service(const std::string& serviceName) {
	// Create service
	// Create a unique global name known within the network
	if ((attachedService = name_attach(NULL, serviceName.c_str(), NAME_FLAG_ATTACH_GLOBAL)) == NULL) {
		perror("Server: name_attach failed");
		return EXIT_FAILURE;
	}

	std::cout << "Service was created: " << serviceName << std::endl;

	return EXIT_SUCCESS;
}

int stop_service() {
	// Server stopped; remove the name from the space
	name_detach(attachedService, 0);
	return EXIT_SUCCESS;
}

int disconnect_service() {
	name_close(server_coid);
	return EXIT_SUCCESS;
}

int connect_to_service(const std::string& serviceName) {
	std::cout << "Connecting to service: " << serviceName << std::endl;
	bool connected = false;
	while(!connected) {
		server_coid = name_open(serviceName.c_str(), NAME_FLAG_ATTACH_GLOBAL);
		connected = server_coid != -1;
		if(!connected) {
			std::cout << "Service not reachable - try again..." << std::endl;
			std::this_thread::sleep_for(std::chrono::seconds(1));
		}
	}

	std::cout << "Connected to service: " << serviceName << std::endl;

	return EXIT_SUCCESS;
}

int send_msg(const std::string& msg) {
	header_t header;
	app_header_t app_header;
	iov_t iov[3];
	char r_msg[512];
	int payload_size = msg.length()+1;
	header.type = STR_MSG;
	header.subtype = 0x00;
	app_header.size = payload_size;
	app_header.count = 123;
	SETIOV(iov+0, &header, sizeof(header));
	SETIOV(iov+1, &app_header, sizeof(app_header));
	SETIOV(iov+2, msg.c_str(), payload_size);

	if (-1 == MsgSendvs(server_coid, iov, 3, r_msg, sizeof(r_msg))){
		perror("Client: MsgSend failed");
		return EXIT_FAILURE;
	}

	// Answer form server should be structured, too.
	printf("Client: Answer from server: %s \n", r_msg);
	return EXIT_SUCCESS;
}

int main(int argc, char **argv) {
	std::string msg;
	int ret;
	if (argc < 2) {
		printf("Usage %s -s | -c \n", argv[0]);
		ret = EXIT_FAILURE;
	}
	else if (strcmp(argv[1], "-c") == 0) {
		printf("Running Slave ... \n");
		msg = "hi from slave";
		create_service(ATTACH_POINT_SLAVE);
		std::thread(receive_msg).detach();
		connect_to_service(ATTACH_POINT_MASTER);
	}
	else if (strcmp(argv[1], "-s") == 0) {
		printf("Running Master ... \n");
		msg = "hi from master";
		create_service(ATTACH_POINT_MASTER);
		std::thread(receive_msg).detach();
		connect_to_service(ATTACH_POINT_SLAVE);
	}
	else {
		printf("Usage %s -s | -c \n", argv[0]);
		ret = EXIT_FAILURE;
	}

	while(true) {
		ret = send_msg(msg);
		std::this_thread::sleep_for(std::chrono::seconds(10));
	}
}
