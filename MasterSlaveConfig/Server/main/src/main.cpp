#include <iostream>
#include <chrono>
#include <thread>
#include <string.h>
#include <pthread.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "hal/hal.h"
#include "events/eventtypes_enum.h"
#include <sys/neutrino.h>
#include <sys/dispatch.h>


#define NO_OF_MSGS 6
#define ATTACH_POINT "myservice"
#define STR_MSG (_IO_MAX + 1)
#define DATA_MSG (_IO_MAX + 2)
/* FÃ¼r die Simulation: */
//#include "../simulation/src/simulationadapterqnx/simqnxgpioapi.h" // must be last include !!!
//#include "../simulation/src/simulationadapterqnx/simqnxirqapi.h" // must be last include !!!
using namespace std;

std::shared_ptr<HAL> hal;
int chid = -1;
typedef struct _pulse header_t;
/* Second header: used by application - if required */
typedef struct
{
	int size;  // size of data block
	int count;
	EventType eventnr;// some counter used by the application
			   // further data fields required by our application
} app_header_t;


static void handle_app_msg(header_t hdr, int rcvid)
{
	// check type
	const char *ret_msg = "Got the message";
	if (DATA_MSG == hdr.type)
	{
		printf("Server: DATA_MSG not supported.\n");
		MsgError(rcvid, EPERM);
		return;
	}
	if (STR_MSG == hdr.type)
	{
		printf("Server: STR_MSG received.\n");
		// read app header
		app_header_t app_header;
		MsgRead(rcvid, &app_header, sizeof(app_header), sizeof(header_t));
		// ToDo return value of MsgRead must be checked, in particular number of read bytes

		// read payload
		char *buf = (char *)malloc(app_header.size);
		// ToDo return value of malloc must be checked

		MsgRead(rcvid, buf, app_header.size, sizeof(header_t) + sizeof(app_header_t));
		// ToDo return value of MsgRead must be checked, in particular number of read bytes


		switch(app_header.eventnr){
		case EventType::HALgelbeLampeAn:
			printf("received HALgelbeLampeAn\n");
//			hal->YellowLampOn();
			break;

		case EventType::HALgelbeLampeAus:
			printf("received HALgelbeLampeAus\n");
//			hal->YellowLampOff();
			break;
		case EventType::HALgrueneLampeAn:
			printf("received HALgrueneLampeAn\n");
//			hal->GreenLampOn();
			break;

		case EventType::HALgrueneLampeAus:
			printf("received HALgrueneLampeAus\n");
//			hal->GreenLampOff();
			break;
		case EventType::HALroteLampeAn:
			printf("received HALroteLampeAn\n");
//			hal->RedLampOn();
			break;
		case EventType::HALroteLampeAus:
			printf("received HALroteLampeAus\n");
//			hal->RedLampOff();
			break;

		default:
			printf("EventType unknown\n");

		}

		printf("Server: got the STR_MSG (count = %d): %s \n", app_header.count, buf);
		// send reply
		MsgReply(rcvid, EOK, ret_msg, strlen(ret_msg) + 1);
		free(buf);
		return;
	}
	// Wrong msg type
	printf("Server: Wrong message type 0x%04X\n", hdr.type);
	MsgError(rcvid, EPERM);
}

static void handle_ONX_IO_msg(header_t hdr, int rcvid)
{
	if (hdr.type == _IO_CONNECT)
	{
		// QNX IO msg _IO_CONNECT was received; answer with EOK
		printf("Server received _IO_CONNECT (sync. msg) \n");
		MsgReply(rcvid, EOK, NULL, 0);
		return;
	}
	// Some other QNX IO message was received; reject it
	printf("Server received unexpected (sync.) msg type = 0x%04X\n", hdr.type);
	MsgError(rcvid, ENOSYS);
}

static void handle_pulse(header_t hdr, int rcvid)
{
	switch (hdr.code)
	{
	case _PULSE_CODE_DISCONNECT:
		printf("Server received _PULSE_CODE_DISCONNECT\n");
		/* A client disconnected all its connections (called
		 * name_close() for each name_open() of our name) or
		 * terminated. */
		ConnectDetach(hdr.scoid);
		break;
	case _PULSE_CODE_UNBLOCK:
		printf("Server received _PULSE_CODE_UNBLOCK\n");
		/* REPLY blocked client wants to unblock (was hit by
		 * a signal or timed out).  It's up to you if you
		 * reply now or later. */
		break;
	default:
		/* A pulse sent by one of your processes or a
		 * _PULSE_CODE_COIDDEATH or _PULSE_CODE_THREADDEATH
		 * from the kernel? */
		printf("Server received some pulse msg.\n");
		break;
	}
}


int server()
{ // Server side of the code
	name_attach_t *attach;

	// Create a global name (/dev/name/global/...) known within the network
	if ((attach = name_attach(NULL, ATTACH_POINT, NAME_FLAG_ATTACH_GLOBAL)) == NULL)
	{
		perror("Server: name_attach failed");
		return EXIT_FAILURE;
	}

	// Do your MsgReceive's here now with the chid
	while (1)
	{
		// Waiting for a message and read first header
		header_t header;
		int rcvid = MsgReceive(attach->chid, &header, sizeof(header_t), NULL);

		if (rcvid == -1)
		{ // Error occurred
			perror("Server: MsgReceived failed");
			break;
		}

		if (rcvid == 0)
		{ // Pulse was received
			handle_pulse(header, rcvid);
			continue;
		}
		// some sync msg was received
		if ((_IO_BASE <= header.type) && (header.type <= _IO_MAX))
		{
			// Some QNX IO msg generated by gns was received
			handle_ONX_IO_msg(header, rcvid);
			continue;
		}
		//  A sync msg (presumable ours) was received; handle it
		handle_app_msg(header, rcvid);
	}

	// Server stopped; remove the name from the space
	name_detach(attach, 0);

	return EXIT_SUCCESS;
}


int main(int argc, char *argv[])
{

//	hal = std::make_shared<HAL>();
	printf("Running Server ... \n");
	int ret = server();
    //print out message
    printf("Server stopped. \n");
    return ret;
}
