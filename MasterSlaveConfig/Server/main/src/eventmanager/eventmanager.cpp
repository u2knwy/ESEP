//
// Created by domxs on 14.04.2023.
//
// event_manager.cpp

#include <algorithm>
#include "eventmanager.h"

// Method for subscribing to events
void EventManager::subscribe(EventType eventType, EventCallback callback) {
    subscriptions_[eventType].push_back(std::move(callback));
}

// Method for unsubscribing from events
void EventManager::unsubscribe(EventType eventType, EventCallback callback) {
    auto& subscribers = subscriptions_[eventType];
    subscribers.erase(
            std::remove_if(subscribers.begin(), subscribers.end(),
                           [&](const EventCallback& cb) { return cb.target<void(const EventData&)>() == callback.target < void(const EventData&)>(); }),
            subscribers.end());
}

// Method for unsubscribing from events
void EventManager::unsubscribeAll(void *objPointer) {

}
void EventManager::handle_app_msg(header_t hdr, int rcvid)
{
	// check type
	const char *ret_msg = "Got the message r1";
	if (DATA_MSG == hdr.type)
	{
		printf("Server: DATA_MSG not supported.\n");
		MsgError(rcvid, EPERM);
		return;
	}
	if (STR_MSG == hdr.type)
	{
		printf("Server: STR_MSG received.\n");
		// read app header
		app_header_t app_header;
		MsgRead(rcvid, &app_header, sizeof(app_header), sizeof(header_t));
		// ToDo return value of MsgRead must be checked, in particular number of read bytes

		// read payload
		char *buf = (char *)malloc(app_header.size);
		// ToDo return value of malloc must be checked

		MsgRead(rcvid, buf, app_header.size, sizeof(header_t) + sizeof(app_header_t));
		// ToDo return value of MsgRead must be checked, in particular number of read bytes


		switch(app_header.eventnr){
		case EventType::HALgelbeLampeAn:
			printf("received HALgelbeLampeAn\n");
//			hal->YellowLampOn();
			break;

		case EventType::HALgelbeLampeAus:
			printf("received HALgelbeLampeAus\n");
//			hal->YellowLampOff();
			break;
		case EventType::HALgrueneLampeAn:
			printf("received HALgrueneLampeAn\n");
//			hal->GreenLampOn();
			break;

		case EventType::HALgrueneLampeAus:
			printf("received HALgrueneLampeAus\n");
//			hal->GreenLampOff();
			break;
		case EventType::HALroteLampeAn:
			printf("received HALroteLampeAn\n");
//			hal->RedLampOn();
			break;
		case EventType::HALroteLampeAus:
			printf("received HALroteLampeAus\n");
//			hal->RedLampOff();
			break;

		default:
			printf("EventType unknown\n");

		}

		printf("Server: got the STR_MSG (count = %d): \n", app_header.count);
		// send reply
		MsgReply(rcvid, EOK, ret_msg, strlen(ret_msg) + 1);
		free(buf);
		return;
	}
	// Wrong msg type
	printf("Server: Wrong message type 0x%04X\n", hdr.type);
	MsgError(rcvid, EPERM);
}

void EventManager::handle_ONX_IO_msg(header_t hdr, int rcvid)
{
	if (hdr.type == _IO_CONNECT)
	{
		// QNX IO msg _IO_CONNECT was received; answer with EOK
		printf("Server received _IO_CONNECT (sync. msg) \n");
		MsgReply(rcvid, EOK, NULL, 0);
		return;
	}
	// Some other QNX IO message was received; reject it
	printf("Server received unexpected (sync.) msg type = 0x%04X\n", hdr.type);
	MsgError(rcvid, ENOSYS);
}

void EventManager::handle_pulse(header_t hdr, int rcvid)
{
	switch (hdr.code)
	{
	case _PULSE_CODE_DISCONNECT:
		printf("Server received _PULSE_CODE_DISCONNECT\n");
		/* A client disconnected all its connections (called
		 * name_close() for each name_open() of our name) or
		 * terminated. */
		ConnectDetach(hdr.scoid);
		break;
	case _PULSE_CODE_UNBLOCK:
		printf("Server received _PULSE_CODE_UNBLOCK\n");
		/* REPLY blocked client wants to unblock (was hit by
		 * a signal or timed out).  It's up to you if you
		 * reply now or later. */
		break;
	default:
		/* A pulse sent by one of your processes or a
		 * _PULSE_CODE_COIDDEATH or _PULSE_CODE_THREADDEATH
		 * from the kernel? */
		printf("Server received some pulse msg.\n");
		break;
	}
}

int EventManager::start(){ // Server side of the code
	name_attach_t *attach;

	// Create a global name (/dev/name/global/...) known within the network
	if ((attach = name_attach(NULL, ATTACH_POINT, NAME_FLAG_ATTACH_GLOBAL)) == NULL)
	{
		perror("Server: name_attach failed. Check GNS status.");
		return EXIT_FAILURE;
	}
	printf("opened server at %i \n", attach->chid);
	// Do your MsgReceive's here now with the chid
	while (1)
	{
		// Waiting for a message and read first header
		header_t header;
		int rcvid = MsgReceive(attach->chid, &header, sizeof(header_t), NULL);

		if (rcvid == -1)
		{ // Error occurred
			perror("Server: MsgReceived failed");
			break;
		}

		if (rcvid == 0)
		{ // Pulse was received
			handle_pulse(header, rcvid);
			continue;
		}
		// some sync msg was received
		if ((_IO_BASE <= header.type) && (header.type <= _IO_MAX))
		{
			// Some QNX IO msg generated by gns was received
			handle_ONX_IO_msg(header, rcvid);
			continue;
		}
		//  A sync msg (presumable ours) was received; handle it
		handle_app_msg(header, rcvid);
	}

	// Server stopped; remove the name from the space
	name_detach(attach, 0);

	return EXIT_SUCCESS;
}


// Method for notifying subscribers when events occur
void EventManager::sendEvent(const EventData& event) {
    const auto& eventType = event.getType();
    if (subscriptions_.count(eventType) > 0) {
        const auto& subscribers = subscriptions_[eventType];
        for (const auto& callback : subscribers) {
            callback(event);
        }
    }
}
